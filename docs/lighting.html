<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta property="og:title" content="Lighting | 3D Game Shaders For Beginners" />
    <meta property="og:description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta property="og:image" content="https://i.imgur.com/JIDwVTm.png" />
    <meta name="twitter:title" content="Lighting | 3D Game Shaders For Beginners" />
    <meta name="twitter:description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta name="twitter:image" content="https://i.imgur.com/JIDwVTm.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <meta name="author" content="David Lettier" />
    <title>Lighting | 3D Game Shaders For Beginners</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
    </style>
    <style>
      code.sourceCode > span { display: inline-block; line-height: 1.25; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode { white-space: pre; position: relative; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      code.sourceCode { white-space: pre-wrap; }
      code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          background-color: #232629;
          color: #7a7c7d;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
      div.sourceCode
        { color: #cfcfc2; background-color: #232629; }
      @media screen {
      code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { color: #cfcfc2; } /* Normal */
      code span.al { color: #95da4c; } /* Alert */
      code span.an { color: #3f8058; } /* Annotation */
      code span.at { color: #2980b9; } /* Attribute */
      code span.bn { color: #f67400; } /* BaseN */
      code span.bu { color: #7f8c8d; } /* BuiltIn */
      code span.cf { color: #fdbc4b; } /* ControlFlow */
      code span.ch { color: #3daee9; } /* Char */
      code span.cn { color: #27aeae; } /* Constant */
      code span.co { color: #7a7c7d; } /* Comment */
      code span.cv { color: #7f8c8d; } /* CommentVar */
      code span.do { color: #a43340; } /* Documentation */
      code span.dt { color: #2980b9; } /* DataType */
      code span.dv { color: #f67400; } /* DecVal */
      code span.er { color: #da4453; } /* Error */
      code span.ex { color: #0099ff; } /* Extension */
      code span.fl { color: #f67400; } /* Float */
      code span.fu { color: #8e44ad; } /* Function */
      code span.im { color: #27ae60; } /* Import */
      code span.in { color: #c45b00; } /* Information */
      code span.kw { color: #cfcfc2; } /* Keyword */
      code span.op { color: #cfcfc2; } /* Operator */
      code span.ot { color: #27ae60; } /* Other */
      code span.pp { color: #27ae60; } /* Preprocessor */
      code span.re { color: #2980b9; } /* RegionMarker */
      code span.sc { color: #3daee9; } /* SpecialChar */
      code span.ss { color: #da4453; } /* SpecialString */
      code span.st { color: #f44f4f; } /* String */
      code span.va { color: #27aeae; } /* Variable */
      code span.vs { color: #da4453; } /* VerbatimString */
      code span.wa { color: #da4453; } /* Warning */
    </style>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
<p><a href="texturing.html"><span class="emoji" data-emoji="arrow_backward">‚óÄÔ∏è</span></a> <a href="index.html"><span class="emoji" data-emoji="arrow_double_up">‚è´</span></a> <a href="#"><span class="emoji" data-emoji="arrow_up_small">üîº</span></a> <a href="#copyright"><span class="emoji" data-emoji="arrow_down_small">üîΩ</span></a> <a href="blinn-phong.html"><span class="emoji" data-emoji="arrow_forward">‚ñ∂Ô∏è</span></a></p>
<h1 id="3d-game-shaders-for-beginners">3D Game Shaders For Beginners</h1>
<h2 id="lighting">Lighting</h2>
<p align="center">
<img src="https://i.imgur.com/zQrA8tr.gif" alt="Lighting" title="Lighting">
</p>

<p>Completing the lighting involves calculating and combining the ambient, diffuse, specular, and emission light aspects. The example code uses either Phong or Blinn-Phong lighting.</p>
<h3 id="vertex">Vertex</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">// ...</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>uniform <span class="kw">struct</span> p3d_LightSourceParameters</span>
<span id="cb1-4"><a href="#cb1-4"></a>  { vec4 color</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>  ; vec4 ambient</span>
<span id="cb1-7"><a href="#cb1-7"></a>  ; vec4 diffuse</span>
<span id="cb1-8"><a href="#cb1-8"></a>  ; vec4 specular</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>  ; vec4 position</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>  ; vec3  spotDirection</span>
<span id="cb1-13"><a href="#cb1-13"></a>  ; <span class="dt">float</span> spotExponent</span>
<span id="cb1-14"><a href="#cb1-14"></a>  ; <span class="dt">float</span> spotCutoff</span>
<span id="cb1-15"><a href="#cb1-15"></a>  ; <span class="dt">float</span> spotCosCutoff</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>  ; <span class="dt">float</span> constantAttenuation</span>
<span id="cb1-18"><a href="#cb1-18"></a>  ; <span class="dt">float</span> linearAttenuation</span>
<span id="cb1-19"><a href="#cb1-19"></a>  ; <span class="dt">float</span> quadraticAttenuation</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>  ; vec3 attenuation</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>  ; sampler2DShadow shadowMap</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>  ; mat4 shadowViewMatrix</span>
<span id="cb1-26"><a href="#cb1-26"></a>  ;</span>
<span id="cb1-27"><a href="#cb1-27"></a>  } p3d_LightSource[NUMBER_OF_LIGHTS];</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co">// ...</span></span></code></pre></div>
<p>For every light, minus the ambient light, Panda3D gives you this convenient struct which is available to both the vertex and fragment shaders. The biggest convenience being the shadow map and shadow view matrix for transforming vertexes to shadow or light space.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a>  <span class="co">// ...</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a>  vertexPosition = p3d_ModelViewMatrix * p3d_Vertex;</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="co">// ...</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; p3d_LightSource.length(); ++i) {</span>
<span id="cb2-8"><a href="#cb2-8"></a>    vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition;</span>
<span id="cb2-9"><a href="#cb2-9"></a>  }</span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>Starting in the vertex shader, you'll need to transform and output the vertex from view space to shadow or light space for each light in your scene. You'll need this later in the fragment shader in order to render the shadows. Shadow or light space is where every coordinate is relative to the light position (the light is the origin).</p>
<h3 id="fragment">Fragment</h3>
<p>The fragment shader is where most of the lighting calculations take place.</p>
<h4 id="material">Material</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// ...</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>uniform <span class="kw">struct</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  { vec4 ambient</span>
<span id="cb3-5"><a href="#cb3-5"></a>  ; vec4 diffuse</span>
<span id="cb3-6"><a href="#cb3-6"></a>  ; vec4 emission</span>
<span id="cb3-7"><a href="#cb3-7"></a>  ; vec3 specular</span>
<span id="cb3-8"><a href="#cb3-8"></a>  ; <span class="dt">float</span> shininess</span>
<span id="cb3-9"><a href="#cb3-9"></a>  ;</span>
<span id="cb3-10"><a href="#cb3-10"></a>  } p3d_Material;</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">// ...</span></span></code></pre></div>
<p>Panda3D gives us the material (in the form of a struct) for the mesh or model you are currently rendering.</p>
<h4 id="multiple-lights">Multiple Lights</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a>  <span class="co">// ...</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>  vec4 diffuse  = vec4(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, diffuseTex.a);</span>
<span id="cb4-4"><a href="#cb4-4"></a>  vec4 specular = vec4(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, diffuseTex.a);</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>Before you loop through the scene's lights, create an accumulator for both the diffuse and specular colors.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a>  <span class="co">// ...</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; p3d_LightSource.length(); ++i) {</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="co">// ...</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  }</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>Now you can loop through the lights, calculating the diffuse and specular colors for each one.</p>
<h4 id="light-related-vectors">Light Related Vectors</h4>
<p align="center">
<img src="https://i.imgur.com/0pzNh5d.gif" alt="Phong Lighting Model" title="Phong Lighting Model">
</p>

<p>Here you see the four major vectors you'll need to calculate the diffuse and specular colors contributed by each light. The light direction vector is the light blue arrow pointing to the light. The normal vector is the green arrow standing straight up. The reflection vector is the dark blue arrow mirroring the light direction vector. The eye or view vector is the orange arrow pointing towards the camera.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a>    <span class="co">// ...</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>    vec3 lightDirection =</span>
<span id="cb6-4"><a href="#cb6-4"></a>        p3d_LightSource[i].position.xyz</span>
<span id="cb6-5"><a href="#cb6-5"></a>      - vertexPosition.xyz</span>
<span id="cb6-6"><a href="#cb6-6"></a>      * p3d_LightSource[i].position.w;</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>The light direction is from the vertex's position to the light's position.</p>
<p>Panda3D sets <code>p3d_LightSource[i].position.w</code> to zero if this is a directional light. Directional lights do not have a position as they only have a direction. So if this is a directional light, the light direction will be the negative or opposite direction of the light as Panda3D sets <code>p3d_LightSource[i].position.xyz</code> to be <code>-direction</code> for directional lights.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a>  <span class="co">// ...</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a>  normal = normalize(vertexNormal);</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>You'll need the vertex normal to be a unit vector. Unit vectors have a length of magnitude of one.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="co">// ...</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>    vec3 unitLightDirection = normalize(lightDirection);</span>
<span id="cb8-4"><a href="#cb8-4"></a>    vec3 eyeDirection       = normalize(-vertexPosition.xyz);</span>
<span id="cb8-5"><a href="#cb8-5"></a>    vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal));</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Next you'll need three more vectors.</p>
<p>You'll need to take the dot product involving the light direction so its best to normalize it. This gives it a distance or magnitude of one (unit vector).</p>
<p>The eye direction is the opposite of the vertex/fragment position since the vertex/fragment position is relative to the camera's position. Remember that the vertex/fragment position is in view space. So instead of going from the camera (eye) to the vertex/fragment, you go from the vertex/fragment to the eye (camera).</p>
<p>The <a href="http://asawicki.info/news_1301_reflect_and_refract_functions.html">reflection vector</a> is a reflection of the light direction at the surface normal. As the light "ray" hits the surface, it bounces off at the same angle it came in at. The angle between the light direction vector and the normal is known as the "angle of incidence". The angle between the reflection vector and the normal is known as the "angle of reflection".</p>
<p>You'll have to negate the reflected light vector as it needs to point in the same direction as the eye vector. Remember the eye direction is from the vertex/fragment to the camera position. You'll use the reflection vector to calculate the intensity of the specular highlight.</p>
<h4 id="diffuse">Diffuse</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1"></a>    <span class="co">// ...</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="dt">float</span> diffuseIntensity  = dot(normal, unitLightDirection);</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="cf">if</span> (diffuseIntensity &lt; <span class="fl">0.0</span>) { <span class="cf">continue</span>; }</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>The diffuse intensity is the dot product between the surface normal and the unit vector light direction. The dot product can range from negative one to one. If both vectors point in the same direction, the intensity is one. Any other case will be less than one.</p>
<p align="center">
<img src="https://i.imgur.com/Nb78z96.gif" alt="The light direction versus the normal direction." title="The light direction versus the normal direction.">
</p>

<p>As the light vector approaches the same direction as the normal, the diffuse intensity approaches one.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a>    <span class="co">// ...</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="cf">if</span> (diffuseIntensity &lt; <span class="fl">0.0</span>) { <span class="cf">continue</span>; }</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>If the diffuse intensity is zero or less, move on to the next light.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a>    <span class="co">// ...</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>    vec4 diffuseTemp =</span>
<span id="cb11-4"><a href="#cb11-4"></a>      vec4</span>
<span id="cb11-5"><a href="#cb11-5"></a>        ( clamp</span>
<span id="cb11-6"><a href="#cb11-6"></a>            (   diffuseTex.rgb</span>
<span id="cb11-7"><a href="#cb11-7"></a>              * p3d_LightSource[i].diffuse.rgb</span>
<span id="cb11-8"><a href="#cb11-8"></a>              * diffuseIntensity</span>
<span id="cb11-9"><a href="#cb11-9"></a>            , <span class="dv">0</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>            , <span class="dv">1</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>            )</span>
<span id="cb11-12"><a href="#cb11-12"></a>        , diffuseTex.a</span>
<span id="cb11-13"><a href="#cb11-13"></a>        );</span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a>    diffuseTemp = clamp(diffuseTemp, vec4(<span class="dv">0</span>), diffuseTex);</span>
<span id="cb11-16"><a href="#cb11-16"></a></span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>You can now calculate the diffuse color contributed by this light. If the diffuse intensity is one, the diffuse color will be a mix between the diffuse texture color and the lights color. Any other intensity will cause the diffuse color to be darker.</p>
<p>Notice how I clamp the diffuse color to be only as bright as the diffuse texture color is. This will protect the scene from being over exposed. When creating your diffuse textures, make sure to create them as if they were fully lit.</p>
<h4 id="specular">Specular</h4>
<p>After diffuse, comes specular.</p>
<p align="center">
<img src="https://i.imgur.com/FnOhXxv.gif" alt="Specular Intensity" title="Specular Intensity">
</p>

<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a>    <span class="co">// ...</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">float</span> specularIntensity = max(dot(reflectedDirection, eyeDirection), <span class="dv">0</span>);</span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a>    vec4 specularTemp =</span>
<span id="cb12-6"><a href="#cb12-6"></a>      clamp</span>
<span id="cb12-7"><a href="#cb12-7"></a>        (   vec4(p3d_Material.specular, <span class="dv">1</span>)</span>
<span id="cb12-8"><a href="#cb12-8"></a>          * p3d_LightSource[i].specular</span>
<span id="cb12-9"><a href="#cb12-9"></a>          * pow</span>
<span id="cb12-10"><a href="#cb12-10"></a>              ( specularIntensity</span>
<span id="cb12-11"><a href="#cb12-11"></a>              , p3d_Material.shininess</span>
<span id="cb12-12"><a href="#cb12-12"></a>              )</span>
<span id="cb12-13"><a href="#cb12-13"></a>        , <span class="dv">0</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        , <span class="dv">1</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>        );</span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>The specular intensity is the dot product between the eye vector and the reflection vector. As with the diffuse intensity, if the two vectors point in the same direction, the specular intensity is one. Any other intensity will diminish the amount of specular color contributed by this light.</p>
<p align="center">
<img src="https://i.imgur.com/4r6wqLP.gif" alt="Shininess" title="Shininess">
</p>

<p>The material shininess determines how spread out the specular highlight is. This is typically set in a modeling program like Blender. In Blender it's known as the specular hardness.</p>
<h4 id="spotlights">Spotlights</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a>    <span class="co">// ...</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="dt">float</span> unitLightDirectionDelta =</span>
<span id="cb13-4"><a href="#cb13-4"></a>      dot</span>
<span id="cb13-5"><a href="#cb13-5"></a>        ( normalize(p3d_LightSource[i].spotDirection)</span>
<span id="cb13-6"><a href="#cb13-6"></a>        , -unitLightDirection</span>
<span id="cb13-7"><a href="#cb13-7"></a>        );</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="cf">if</span> (unitLightDirectionDelta &lt; p3d_LightSource[i].spotCosCutoff) { <span class="cf">continue</span>; }</span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="co">// ...</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>}</span></code></pre></div>
<p>This snippet keeps fragments outside of a spotlight's cone or frustum from being affected by the light. Fortunately, Panda3D <a href="https://github.com/panda3d/panda3d/blob/daa57733cb9b4ccdb23e28153585e8e20b5ccdb5/panda/src/display/graphicsStateGuardian.cxx#L1705">sets up</a> <code>spotDirection</code> and <code>spotCosCutoff</code> to also work for directional lights and points lights. Spotlights have both a position and direction. However, directional lights only have a direction and point lights only have a position. Still, this code works for all three lights avoiding the need for noisy if statements.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a>        <span class="co">// ...</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>        , -unitLightDirection</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="co">// ...</span></span></code></pre></div>
<p>You must negate <code>unitLightDirection</code>. <code>unitLightDirection</code> goes from the fragment to the spotlight and you need it to go from the spotlight to the fragment since the <code>spotDirection</code> goes directly down the center of the spotlight's frustum some distance away from the spotlight's position.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a>spotCosCutoff = cosine(<span class="fl">0.5</span> * spotlightLensFovAngle);</span></code></pre></div>
<p>For a spotlight, if the dot product between the fragment-to-light vector and the spotlight's direction vector is less than the cosine of half the spotlight's field of view angle, the shader disregards this light's influence.</p>
<p>For directional lights and point lights, Panda3D sets <code>spotCosCutoff</code> to negative one. Recall that the dot product ranges from negative one to one. So it doesn't matter what the <code>unitLightDirectionDelta</code> is because it will always be greater than or equal to negative one.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a>    <span class="co">// ...</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a>    diffuseTemp *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent);</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Like the <code>unitLightDirectionDelta</code> snippet, this snippet also works for all three light types. For spotlights, this will make the fragments brighter as you move closer to the center of the spotlight's frustum. For directional lights and point lights, <code>spotExponent</code> is zero. Recall that anything to the power of zero is one so the diffuse color is one times itself meaning it is unchanged.</p>
<h4 id="shadows">Shadows</h4>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1"></a>    <span class="co">// ...</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="dt">float</span> shadow =</span>
<span id="cb17-4"><a href="#cb17-4"></a>      textureProj</span>
<span id="cb17-5"><a href="#cb17-5"></a>        ( p3d_LightSource[i].shadowMap</span>
<span id="cb17-6"><a href="#cb17-6"></a>        , vertexInShadowSpaces[i]</span>
<span id="cb17-7"><a href="#cb17-7"></a>        );</span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a>    diffuseTemp.rgb  *= shadow;</span>
<span id="cb17-10"><a href="#cb17-10"></a>    specularTemp.rgb *= shadow;</span>
<span id="cb17-11"><a href="#cb17-11"></a></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Panda3D makes applying shadows relatively easy by providing the shadow map and shadow transformation matrix for every scene light. To create the shadow transformation matrix yourself, you'll need to assemble a matrix that transforms view space coordinates to light space (coordinates are relative to the light's position). To create the shadow map yourself, you'll need to render the scene from the perspective of the light to a framebuffer texture. The framebuffer texture must hold the distances from the light to the fragments. This is known as a "depth map". Lastly, you'll need to manually give to your shader your DIY depth map as a <code>uniform sampler2DShadow</code> and your DIY shadow transformation matrix as a <code>uniform mat4</code>. At this point, you've recreated what Panda3D does for you automatically.</p>
<p>The shadow snippet shown uses <code>textureProj</code> which is different from the <code>texure</code> function shown earlier. <code>textureProj</code> first divides <code>vertexInShadowSpaces[i].xyz</code> by <code>vertexInShadowSpaces[i].w</code>. After this, it uses <code>vertexInShadowSpaces[i].xy</code> to locate the depth stored in the shadow map. Next it uses <code>vertexInShadowSpaces[i].z</code> to compare this vertex's depth against the shadow map depth at <code>vertexInShadowSpaces[i].xy</code>. If the comparison passes, <code>textureProj</code> will return one. Otherwise, it will return zero. Zero meaning this vertex/fragment is in the shadow and one meaning this vertex/fragment is not in the shadow.</p>
<p><code>textureProj</code> can also return a value between zero and one depending on how the shadow map was set up. In this instance, <code>textureProj</code> performs multiple depth tests using neighboring depth values and returns a weighted average. This weighted average can give shadows a softer look.</p>
<h4 id="attenuation">Attenuation</h4>
<p align="center">
<img src="https://i.imgur.com/jyatr7l.png" alt="Attenuation" title="Attenuation">
</p>

<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a>    <span class="co">// ...</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="dt">float</span> lightDistance = length(lightDirection);</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="dt">float</span> attenuation =</span>
<span id="cb18-6"><a href="#cb18-6"></a>        <span class="dv">1</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>      / ( p3d_LightSource[i].constantAttenuation</span>
<span id="cb18-8"><a href="#cb18-8"></a>        + p3d_LightSource[i].linearAttenuation</span>
<span id="cb18-9"><a href="#cb18-9"></a>        * lightDistance</span>
<span id="cb18-10"><a href="#cb18-10"></a>        + p3d_LightSource[i].quadraticAttenuation</span>
<span id="cb18-11"><a href="#cb18-11"></a>        * (lightDistance * lightDistance)</span>
<span id="cb18-12"><a href="#cb18-12"></a>        );</span>
<span id="cb18-13"><a href="#cb18-13"></a></span>
<span id="cb18-14"><a href="#cb18-14"></a>    diffuseTemp.rgb  *= attenuation;</span>
<span id="cb18-15"><a href="#cb18-15"></a>    specularTemp.rgb *= attenuation;</span>
<span id="cb18-16"><a href="#cb18-16"></a></span>
<span id="cb18-17"><a href="#cb18-17"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>The light's distance is just the magnitude or length of the light direction vector. Notice it's not using the normalized light direction as that distance would be one.</p>
<p>You'll need the light distance to calculate the attenuation. Attenuation meaning the light's influence diminishes as you get further away from it.</p>
<p>You can set <code>constantAttenuation</code>, <code>linearAttenuation</code>, and <code>quadraticAttenuation</code> to whatever values you would like. A good starting point is <code>constantAttenuation = 1</code>, <code>linearAttenuation = 0</code>, and <code>quadraticAttenuation = 1</code>. With these settings, the attenuation is one at the light's position and approaches zero as you move further away.</p>
<h4 id="final-light-color">Final Light Color</h4>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1"></a>    <span class="co">// ...</span></span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a>    diffuse  += diffuseTemp;</span>
<span id="cb19-4"><a href="#cb19-4"></a>    specular += specularTemp;</span>
<span id="cb19-5"><a href="#cb19-5"></a></span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>To calculate the final light color, add the diffuse and specular together. Be sure to add this to the accumulator as you loop through the scene's lights.</p>
<h4 id="ambient">Ambient</h4>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// ...</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a>uniform sampler2D p3d_Texture1;</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">// ...</span></span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a>uniform <span class="kw">struct</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>  { vec4 ambient</span>
<span id="cb20-9"><a href="#cb20-9"></a>  ;</span>
<span id="cb20-10"><a href="#cb20-10"></a>  } p3d_LightModel;</span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="co">// ...</span></span>
<span id="cb20-13"><a href="#cb20-13"></a></span>
<span id="cb20-14"><a href="#cb20-14"></a>in vec2 diffuseCoord;</span>
<span id="cb20-15"><a href="#cb20-15"></a></span>
<span id="cb20-16"><a href="#cb20-16"></a>  <span class="co">// ...</span></span>
<span id="cb20-17"><a href="#cb20-17"></a></span>
<span id="cb20-18"><a href="#cb20-18"></a>  vec4 diffuseTex  = texture(p3d_Texture1, diffuseCoord);</span>
<span id="cb20-19"><a href="#cb20-19"></a></span>
<span id="cb20-20"><a href="#cb20-20"></a>  <span class="co">// ...</span></span>
<span id="cb20-21"><a href="#cb20-21"></a></span>
<span id="cb20-22"><a href="#cb20-22"></a>  vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex;</span>
<span id="cb20-23"><a href="#cb20-23"></a></span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="co">// ...</span></span></code></pre></div>
<p>The ambient component to the lighting model is based on the material's ambient color, the ambient light's color, and the diffuse texture color.</p>
<p>There should only ever be one ambient light. Because of this, the ambient color calculation only needs to occur once. Contrast this with the diffuse and specular color which must be accumulated for each spot/directional/point light. When you reach <a href="ssao.html">SSAO</a>, you'll revisit the ambient color calculation.</p>
<h4 id="putting-it-all-together">Putting It All Together</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1"></a>  <span class="co">// ...</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a>  vec4 outputColor = ambient + diffuse + specular + p3d_Material.emission;</span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>The final color is the sum of the ambient color, diffuse color, specular color, and the emission color.</p>
<h3 id="source">Source</h3>
<ul>
<li><a href="https://github.com/lettier/3d-game-shaders-for-beginners/blob/master/demonstration/src/main.cxx" target="_blank" rel="noopener noreferrer">main.cxx</a></li>
<li><a href="https://github.com/lettier/3d-game-shaders-for-beginners/blob/master/demonstration/shaders/vertex/base.vert" target="_blank" rel="noopener noreferrer">base.vert</a></li>
<li><a href="https://github.com/lettier/3d-game-shaders-for-beginners/blob/master/demonstration/shaders/fragment/base.frag" target="_blank" rel="noopener noreferrer">base.frag</a></li>
</ul>
<h2 id="copyright">Copyright</h2>
<p>(C) 2019 David Lettier <br> <a href="https://www.lettier.com">lettier.com</a></p>
<p><a href="texturing.html"><span class="emoji" data-emoji="arrow_backward">‚óÄÔ∏è</span></a> <a href="index.html"><span class="emoji" data-emoji="arrow_double_up">‚è´</span></a> <a href="#"><span class="emoji" data-emoji="arrow_up_small">üîº</span></a> <a href="#copyright"><span class="emoji" data-emoji="arrow_down_small">üîΩ</span></a> <a href="blinn-phong.html"><span class="emoji" data-emoji="arrow_forward">‚ñ∂Ô∏è</span></a></p>
  </body>
</html>
